import type { Phase } from "@/lib/contracts/idea";
import { createSupabaseServerClient } from "@/lib/supabase/server";
import {
  addActivity,
  appendDecision,
  completePhaseRun,
  failPhaseRun,
  updateIdeaPhase,
} from "@/lib/server/repositories/idea-repository";

type RunInput = {
  ownerId: string;
  ideaId: string;
  runId: string;
  phase: Phase;
  contextDelta?: Record<string, unknown>;
};

function defaultMessages(phase: Phase) {
  switch (phase) {
    case "extract":
      return {
        analyze: "Deduplicing raw thoughts into core idea statements.",
        output: "Created initial idea graph and ambiguity labels.",
        decision: "Proceed to interrogation on current extraction quality.",
      };
    case "interrogate":
      return {
        analyze: "Challenging assumptions and identifying contradiction risk.",
        output: "Generated adversarial questions and kill-criteria.",
        decision: "Assumptions are testable; move to evidence grounding.",
      };
    case "ground":
      return {
        analyze: "Mapping market, competitor, and regulatory signals.",
        output: "Evidence items linked to assumptions and constraints.",
        decision: "Signal quality is sufficient for planning.",
      };
    case "plan":
      return {
        analyze: "Synthesizing a buildable MVP scope with risk register.",
        output: "Created execution-ready product plan.",
        decision: "MVP scope frozen for implementation start.",
      };
    case "build":
      return {
        analyze: "Selecting stack recommendation and implementation path.",
        output: "Execution bridge generated for build kickoff.",
        decision: "Recommended Next.js + Supabase implementation path.",
      };
  }
}

async function persistPhaseArtifacts(input: RunInput) {
  const db = createSupabaseServerClient();
  const now = new Date().toISOString();
  const baseArtifacts: Record<string, unknown> = {
    phase: input.phase,
    generatedAt: now,
    contextDelta: input.contextDelta ?? {},
  };

  if (input.phase === "extract") {
    await db.from("idea_assumptions").insert({
      owner_id: input.ownerId,
      idea_id: input.ideaId,
      text: "Target users actively feel planning friction before coding.",
      confidence: 0.72,
      status: "open",
    });
  }

  if (input.phase === "ground") {
    await db.from("idea_evidence").insert({
      owner_id: input.ownerId,
      idea_id: input.ideaId,
      source_type: "note",
      claim: "Users pay for clarity and workflow continuity, not token volume.",
      citation: "Foundry synthesis",
      relevance_score: 0.88,
    });
  }

  if (input.phase === "plan") {
    await db.from("idea_constraints").insert({
      owner_id: input.ownerId,
      idea_id: input.ideaId,
      category: "technical",
      detail: "Need strict server boundary and typed contracts before growth.",
      severity: "medium",
    });
  }

  if (input.phase === "build") {
    await db.from("idea_execution_paths").insert({
      owner_id: input.ownerId,
      idea_id: input.ideaId,
      stack_recommendation: "custom",
      rationale: "Requires structured backend orchestration and durable idea memory.",
      effort: "medium",
      risk: "medium",
    });
  }

  return baseArtifacts;
}

export async function runPhaseEngine(input: RunInput) {
  const phaseText = defaultMessages(input.phase);

  try {
    await addActivity(input.ownerId, input.ideaId, input.runId, "analyze", phaseText.analyze);
    const artifacts = await persistPhaseArtifacts(input);
    await addActivity(input.ownerId, input.ideaId, input.runId, "output", phaseText.output);

    await appendDecision(input.ownerId, input.ideaId, phaseText.decision, "Generated by Foundry engine.");
    await updateIdeaPhase(input.ideaId, input.phase);
    await completePhaseRun(input.runId, artifacts);
    return { status: "done", output: artifacts };
  } catch (error) {
    const reason = error instanceof Error ? error.message : "Unknown engine error";
    await failPhaseRun(input.runId, reason);
    throw error;
  }
}

